{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands-if-you-can-see-this-something-is-wrong-with-pages","title":"Commands - If you can see this, something is wrong with pages","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"Pandas/","title":"Pandas","text":""},{"location":"Pandas/#handy-stuff","title":"Handy Stuff","text":"<ul> <li><code>df.col.idxmax()</code> - index of the first occurrence of max value in col</li> <li><code>df[col].str.lower().str.count(word)</code> return the occurrence of the word in the values of col - almost instant</li> <li>chaining commands - wanna apply condition in mid chain - use lambda</li> </ul>"},{"location":"Pandas/#creation","title":"Creation","text":"<ul> <li><code>pd.DataFrame(dict)</code> - keys will be column headings<ul> <li><code>index=[]</code> - custom row labels, other than 0,1,2...</li> </ul> </li> <li><code>pd.Series([])</code> - single column data structure</li> <li><code>pd.read_csv(path, index_col='col to set as index')</code> - csv to DataFrame<ul> <li><code>index_col=0</code> - column to use as row labels/index in csv</li> </ul> </li> <li><code>df.shape</code> - (rows, columns) of DataFrame</li> <li><code>df.head()</code> - first five rows</li> </ul>"},{"location":"Pandas/#retrieval","title":"Retrieval","text":"<ul> <li><code>df[column_name]</code> or <code>df.column_name</code> - get the column<ul> <li><code>df[col_name][row_num]</code></li> </ul> </li> <li><code>df.iloc[index]</code> - data selection based on index/row<ul> <li><code>df.loc[label]</code> - data selection based on label</li> <li>both are row-first, column-second</li> </ul> </li> <li><code>df.iloc[:,0]</code> - first column, all rows(range can be given 1 : 4)<ul> <li><code>df.iloc[[list_of_rows], cols/list_of_cols]</code></li> </ul> </li> <li><code>df.iloc[-5:]</code> - last five rows</li> <li>iloc is exclusive and loc is inclusive<ul> <li><code>[0:10]</code> in iloc will give <code>0, 1, 2, ..., 9</code></li> <li><code>[0:10]</code> in loc will give <code>0, 1, 2, ..., 10</code></li> </ul> </li> <li><code>df.set_index(col_name)</code> - use col as index</li> <li><code>df.loc[(df.col == 'col_value') &amp; (condition 2) | (condition 3)]</code> - filtering the data<ul> <li><code>&amp;</code> is and, <code>|</code> is or</li> <li><code>df.loc[(row filteration  or col on condition), [list of cols want to select]]</code> - multi cols on the basis of a condition or single col without square bracket</li> </ul> </li> <li><code>df.loc[df.col.isin([list_of_values])]</code> - something like \"if x in y\"</li> <li><code>df.loc[df.col.isnull()]</code> or <code>df.loc[df.col.notnull()]</code></li> <li><code>df[col] = val</code> - all rows of col will be val, range can be given in place of val</li> </ul>"},{"location":"Pandas/#summarization-and-representation","title":"Summarization and Representation","text":"<ul> <li><code>df.col.describe()</code> - High-Level Statistical report of the col<ul> <li>type-aware - output changes based on data/col</li> </ul> </li> <li><code>df.col.mean()</code></li> <li><code>df.col.unique()</code> - list of unique vals in col</li> <li> <p><code>df.col.value_counts()</code> - unique values and their frequency</p> </li> <li> <p><code>df.col.map(function)</code> - a new dataframe - with vals of col - modified by the func</p> </li> <li><code>df.apply(function, axis=0 or 1)</code> - equivalent to above but transform the whole dataframe<ul> <li>axis = 0 - row</li> <li>axis = 1 - column</li> </ul> </li> <li>Both above return new df, do not change the original data</li> <li>operators like <code>+ - == &lt; &gt;</code> are faster than map() and apply() but the later are more flexible and used for more advanced things</li> </ul>"},{"location":"Pandas/#grouping-and-sorting","title":"Grouping and Sorting","text":"<ul> <li><code>df.groupby(col for grouping)[col_for_operation].summary_method()</code><ul> <li><code>df.groupby[].apply()</code> - gives a slice of dataframe - accessible via apply()</li> </ul> </li> <li><code>df.groupby(['col_1', 'col_2'])</code> - combination of both/all cols<ul> <li>every group has same col_1 and col_2 values</li> </ul> </li> <li><code>df.groupby(col).col.agg([len, min, max, etc])</code> - lets you execute multiple methods on the same dataset<ul> <li>len is used to count rows</li> <li><code>count()</code> only counts the non-NaN</li> <li><code>len()</code> counts all rows</li> </ul> </li> <li>groupby with multi cols gives Multi-index - the most common method used - <code>reset_index()</code> - convert back to regular index</li> <li><code>df.sort_values(by='col', ascending=True/False)</code><ul> <li><code>df.sort_index()</code> - same arguments, just sorting basis is different</li> </ul> </li> <li><code>df.sort_values(by=['col_1', 'col_2'])</code> - first sort as col_1 then col_2</li> <li><code>df.groupby(col).size()</code> - count the number of rows in each group</li> </ul>"},{"location":"Pandas/#data-types-and-missing-values","title":"Data Types and Missing Values","text":"<ul> <li><code>df.col.dtype</code> - data type of the col<ul> <li><code>df.dtypes</code> - of all cols</li> </ul> </li> <li>string cols falls under dtype Object</li> <li> <p>type conversion - <code>df.col.astype('type')</code></p> </li> <li> <p>Missing -&gt; NaN -&gt; always float64</p> </li> <li><code>df[col].isnull()</code> or <code>df[col].notnull()</code> - grab or not grab the NaN<ul> <li><code>df[col].isnull().sum()</code> - count total number of NaN</li> </ul> </li> <li><code>df.col.fillna('val')</code> - replace all NaN with val<ul> <li><code>df.col.fillna(method='bffill', inplace=True/False)</code> - backfill strategy</li> <li>inplace - True - make changes in original df</li> </ul> </li> <li><code>df.col.replace('val_1', 'val_2')</code> - in col, replace val_1 with val_2</li> </ul>"},{"location":"Pandas/#renaming-and-combining","title":"Renaming and Combining","text":"<ul> <li><code>df.rename(columns={'old_col':'new_col'}, inplace=True/False)</code><ul> <li><code>df['new_col'] = df.pop('old_col')</code></li> <li><code>df.rename(index={0:'first', 1:'second'})</code></li> </ul> </li> <li> <p><code>df.rename_axis('new_row_name', axis='rows').rename_axis('new_col_name', axis='columns')</code></p> </li> <li> <p>Complexity - <code>concat()</code> &lt; <code>join()</code> &lt; <code>merge()</code></p> </li> <li><code>pd.concat([df1, df2])</code></li> <li><code>join()</code> - combine diff dataframe objects with common index </li> <li><code>left.join(right, lsuffix='_from_left', rsuffix='_from_right')</code><ul> <li><code>left</code> and <code>right</code> is df names</li> <li>lsuffix and rsuffix helps - same col names - no overlapping</li> </ul> </li> <li><code>df1.set_index(\"col\").join(df2.set_index(\"col\"))</code><ul> <li>join for combining - two same cols in dfs</li> <li>merge is better to join when joining on the basis of non-index</li> </ul> </li> </ul>"},{"location":"Python/","title":"Python","text":""},{"location":"Python/#strings","title":"Strings","text":"<p><pre><code>string = \"Pluto is a planel!\"\n\nstring.startswith(\"substring\")\nstring.endswith(\"substring\")\n\nstring.split() # list of words divided at spaces by default \ntemp = \"1956-454-841\"\ntemp.split('-') # split from the -\n\nstring.join() # the reverse of the above\n`/`.join([day, month, yer]) # 06/11/2025\n\npluto_mass = 1.303 * 10**22\nearth_mass = 5.9722 * 10**24\npopulation = 52910390\n#         2 decimal points   3 decimal points, format as percent     separate with commas\n\"{} weighs about {:.2} kilograms ({:.3%} of Earth's mass). It is home to {:,} Plutonians.\".format(\n    planet, pluto_mass, pluto_mass / earth_mass, population,\n)\n</code></pre> - To learn more about <code>{:.2}</code>, <code>{:.3%}</code>, etc, Go to Python Format Specification Mini-language Official Docs or pyformat.info</p>"},{"location":"Python/#functions","title":"Functions","text":"<pre><code>def function_name(parameters):\n    # code_here\n    return value1, value2 # if you want to have some thing from the function as well to carry forward\n\nx, y = function_name(arguments) # value1 will be assigned to x and value2 to y\n# arguments and parameters are almost some, the difference is there place of declaration\n\n# DEFAULT VALUES\ndef func1(a = 12):\n    # some processing\n    return result\n\nword = \"something\"\nword.find(\"e\") # numeral, return the index of first occurance,\n# if no occurance, return -1\n\n\"e\" in word # boolean, return True or False\n</code></pre>"},{"location":"Python/#list-and-tuple","title":"List and Tuple","text":"<pre><code>list_data = [\"content\", \"hello\", 1.2, -1]\n\nlen(list_data)              # 4\nsum(list_1)                 # adds all the elements of the list together\nmax(list_1)                 # returns the highest value in the list\nmin(list_1)\nsorted(list_1)              # iterable as argument and then sort the list\n# it creates a new list and do not interfere the data in original list\nnew_list = (list_1, reverse=True) # change the order\n\nlist_data.append(\"some_data\")    # add the data at the end of the list\nlist_data.insert(index, \"data2\") # add the data at the specified\nlist_data.pop(index)             # deletes the item at the index\n# also return the item that it deleted, no arguments - delete the last item\nlist_data.index(\"data\") # return the index at which \"data\" is stored\n\nfor x in list_1:\n    # in is used to easily check whether some element is the collection data type or not    \n\n\n# TUPLES\ntuple_data = (val1, val1, val2, val2, val2, val3, val4)\n\ntuple_data.count(val1)            # 2\n# ALL THE METHODS OF LIST CAN BE USED WITH TUPLES AS WELL AS LONG AS THEY ARE NOT BEING USED FOR MODIFICATIONS\n\nsample_tuple = (some1, some2, some3)\ndata1, data2, data3 = sample_tuple # the values of tuple will be assigned to variables in the sequence of occurence BUT NUMBER OF VARIABLE SHOULD MATCH THE NUMBER OF ELEMENTS IN THE TUPLE\n\nsample_tuple = (v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14) # unknown number of elements\n\nfirst, second, *remaining = sample_tuple\n# first will be assigned - v1\n# second will be assigned - v2\n# remaining will be assigned - a LIST of all the remaining items\n\nnew_list = [x for x in range(1, 51)]\nvariable = [expression for item in iterable if condition]\n# expression is the operation that will be run on each item\n# if no transformation needed, expression can be just items\n# only operate the experssion on item if condition is True\nnew_list = [x*2 for x in range(1, 51)]\n</code></pre>"},{"location":"Python/#sets","title":"Sets","text":"<ul> <li>A datatype perfect for storing unique data.</li> <li>Unordered collection made with <code>{ }</code>. It means they do not support indexing or slicing.</li> <li>It cannot have duplicate data, even if there is, there will be no error but further occurrence will be ignored.</li> <li>Can have data of different data types</li> <li>Mutable</li> <li><code>set.add(data)</code> and <code>set.remove(data)</code><ul> <li><code>set.append()</code> will not work because it works on indexed or ordered data only.</li> </ul> </li> <li><code>set.clear()</code> - no arguments needed, empty the whole set or deletes all the items in the set.</li> <li><code>set1.union(set2)</code> - merge both sets omitting the duplicate values.</li> <li><code>set1.difference(set2)</code> - only returns the set with the data that is present in set1 and not in set2, hence the data that is unique in set1</li> </ul>"},{"location":"Python/#dictionaries","title":"Dictionaries","text":"<ul> <li>Any kind of immutable data type can be used as keys and for values, any data type can be used.</li> <li>Values with duplicate keys will be overwritten. <pre><code>data = {\n    \"name\":\"something\",\n    \"class\":4,\n    \"class\",6\n}\n\nprint(data[\"class\"])     # 6\nprint(data.get(\"class\")) # 6\n\ndata.keys()              \ndata.values()\n# all keys and values in a view object which can be converted into list\n\ndata.items()  # all the data as key:value pairs\n\ndata[\"new key\"] = \"new value\"\n# a new key and value or basically a new data can be assigned like this\n\n# to change the data of a key\ndata[\"key\"] = \"value\"\ndata.update({\"key\":\"value\"}) # the argument must be dictionary\n# if the dictionary in the above argument has new key with value, it will added\n\ndata.pop(\"key\")\n\n\"something\" in data # by default, it will check in the keys, hence data.keys()\n\"something\" in data.values()\n# same logic as above for iterations or loops as well\n</code></pre></li> </ul>"},{"location":"Python/#exception-handling","title":"Exception Handling","text":"<p>Bugs: Mistake in code that does not stop the program from completion but leads to unwanted/unexpected or wrong result or behavior. Exception: Mistakes that interrupts the code from executing at the first encountered.</p>"},{"location":"Python/#some-exceptions","title":"Some Exceptions","text":"<ul> <li><code>NameError</code> - Unknown variable is used.</li> <li><code>SyntaxError</code> - missing punctuation, missing dot or unclosed bracket, etc.</li> <li><code>IndexError</code> - Using index outside of the valid range.</li> <li><code>TypeError</code> - Function is called on the wrong data type.<ul> <li>When the source of exception or error is from the function itself, such as trying to mutate the elements in tuple. You are trying to do a function which is which cannot be proceeded so a type error.</li> </ul> </li> <li><code>ValueError</code> - When the value is unacceptable. <code>int(\"112A\")</code><ul> <li>When the function is not raising the error but the way you have provided it, the value is raising the error, hence value error.</li> </ul> </li> </ul> <pre><code>try:\n    # CODE HERE \nexcept ERROR:\n    # CODE HERE\nexcept ERROR:\n    # CODE HERE\nexcept ERROR:\n    # CODE HERE\n</code></pre> <p>The code block that might throw an error will be under try and if the mentioned ERROR happened, the execution will not stop and the code block under the except will be executed.</p> <p>Add all the exceptions that might arise during the execution of the try block, in more except block</p> <p>The below code will catch any kind of exception as the kind of exceptions is not defined. <pre><code>try:\n    # CODE HERE\nexcept:\n    # CODE HERE\n</code></pre></p> <p>In the below code, even if the exception is occurred or not, the code under the finally will run for sure.</p> <pre><code>try:\n    # CODE HERE\nexcept ERROR:\n    # CODE HERE\nfinally:\n    # CODE HERE\n</code></pre> <p>In the below code, if there are no exception occurred during the execution of the try block, the code under the else block will be executed, only if the there is no exception <pre><code>try:\n    # CODE HERE\nexcept ERROR:\n    # CODE HERE\nelse:\n    # CODE HERE\n</code></pre></p> <p>You can raise exceptions by your own if you want to. <pre><code>if x != \"demanded value\":\n    raise ValueError(\"description to display in the terminal however not necessary\")\n\n# YOU CAN make your custom Error(s) as well by subclassing the python's Exception class. LEARN about it when needed.\n</code></pre></p>"},{"location":"Python/#functional-programming","title":"Functional Programming","text":"<pre><code>def function():\n    # SOME CODE\n\nvar1 = function\nvar2 = function()\n\ndef function_with_default_values_for_parameters(a, b = 10):\n    # if a is not passed, it will be error, If b is not passed, 10 will be taken as the value of b\n\n# var1 stores the function and function can be called using var1()\n# so it is basically like an alias\n\n# var2 executes the function and store the return value\n# None if there is no return \n\n# functions can be used as a argument for other functions as well\n# FUNCTIONS THAT TAKE FUNCTIONS AS ARGUMENTS are called HIGHER ORDER FUNCTIONS, they are used for processing various functions and get specific result, they are return functions\n\n# PURE FUNCTION: that gives the same result(s) for the same input(s) and it does not affect anything outside the function, it means it does not do anything outside the function, printing or anything such as modifying the global variables is also NOT DONE by this function. It does not affect the extenal world in the slightest.\n# SIMILARLY, if the function is depended on the something external other than the arguments given, such as global variables or input() from the console, it will lead to function being IMPURE FUNCTION as it is interacting, changing or depending on the extenal environment.\n</code></pre>"},{"location":"Python/#lambda-expression","title":"Lambda Expression","text":"<p>Allows to make compact functions without needing the formal structure of function definition.</p> <p>They are functions without a name, created to do something quick and small and simple task.</p> <p>Also known as anonymous functions as they do not have a name. <pre><code>greet = lambda name: \"Welcome, \" + name\nprint(greet(\"name\"))\n\nlambda argument: expression\nlambda price: price * 0.9\n# expresson perform a single task and return a result\n\n# as in the first line, a name is assigned to the function hence can be called as a regular function\n\n# they can also take multiple arguments\nlambda a, b: a * b\n</code></pre></p> <p>The power of lambda functions is explained or can be seen when working with data manipulation and transformation.</p> <p>map(): Applies a specified function to every element in an iterable. It provide a result that can be converted into using list() for easy viewing and further use. <pre><code>lower_names = ['apple', 'banana', 'catpucchin', 'dangerous']\n\ndef to_upper(name):\n    return name.upper()\n\n# first is function and 2nd argument is iterable\nconverted_to_upper = map(to_upper, lower_names) # all the elements of lower_names will be passed as arguments to to_upper function\n\nconverted_to_upper = list(converted_to_upper)\n\n\n# a better way for above\nconverted_to_upper = list(map(to_upper, lower_names))\n\nprint(converted_to_upper)\n\n\n\n\n# LAMBDA EXPRESSIONS CAN BE USED ABOVE TO OMIT THE NEED TO DEFINING A NEW FUNCTION\nconverted_to_upper = list(map(lambda name: name.upper(), lower_names))\n</code></pre></p> <p>filter(): almost similar to map() but map() executes a function on all the elements of the iterable, filter() passes the elements through a conditional and if the conditional returns true, only that element will be returned from the filter function. Useful for extraction of the data with a certain condition or criteria. <pre><code>numbers = [1, 2, 3, 4, 5, 6]\n\nfiltered_data = list(filter(lambda num: num % 2 == 0, numbers))\n\nprint(filtered_data) # [2, 4, 6]\n</code></pre></p>"},{"location":"Python/#args-and-kwargs","title":"*args and **kwargs","text":"<p>*args: allows you to provide any number of arguments before calling the function. It converts all the arguments into a iterable(tuple).</p> <p>**kwargs: allows to provide any number of arguments and they will be converted into the key-value pairs iterables.</p> <p>[!NOTE] Remember args and kwargs are just terms, they are not static words, the main player here is * and ** which is unpacking operator.  It converts the unknown number of arguments into an iterable, either a ordered iterable(tuple) or key value pair iterable(dictionary)</p> <pre><code>def total(*numbers):\n    return sum(numbers)\n\nprint(total(1,2,23,12,312,312,31,23,123,12,3)) # 854\n</code></pre> <p>Here, all the arguments are converted into a tuple and assigned to numbers.</p> <pre><code>def function(argument1, argument2, *unknown_arguments):\n    # code here\n\n# THE FUNCTION will have at least 2 arguments to execute and all the other will be assigned to the unknown_arguments.\n# The static or fixed arguments but be written before the unpacking operator.\n</code></pre> <p>The first line that contains the name and arguments of the function is known as function signature</p>"},{"location":"Python/#decorators","title":"Decorators","text":"<p>Special functions that modify or enhance other functions. They basically takes a function as argument, make some changes and return the same function again. <pre><code>def decorator(func):\n    # code here\n\n@decorator\ndef some_func():\n    # code here\n    return #code here\n\n\n# The above is basically like \ndecorator(some_func)\n\n# it is a good practice to have 'decorator' in the decorator function\n</code></pre></p>"},{"location":"Python/#perfect-example","title":"Perfect Example","text":"<pre><code>def greet_decorator(func):\n    def wrapper():\n        print(\"Hello!\")   # extra code before\n        func()            # call the original function\n        print(\"Goodbye!\") # extra code after\n    return wrapper\n\n@greet_decorator\ndef say_name():\n    print(\"I\u2019m Buddy!\")\n\nsay_name()\n</code></pre> <ul> <li> <p>Python defines the decorator</p> <ul> <li><code>greet_decorator</code> is defined \u2014 no execution yet.</li> </ul> </li> <li> <p>Python reaches <code>@greet_decorator</code></p> <ul> <li>It immediately executes <code>say_name = greet_decorator(say_name)</code>.</li> <li>Inside <code>greet_decorator</code>:<ul> <li>The original <code>say_name</code> is passed as the <code>func</code> argument.</li> <li>The inner function <code>wrapper</code> is defined (but not run/executed yet).</li> <li><code>wrapper</code> closes over <code>func</code> (remembers it).<ul> <li>Makes a unique instance of the <code>wrapper</code> in the backend and assigns(alias's) it to the host function or the <code>func</code>(<code>say_name()</code> in this case)</li> </ul> </li> <li>Then <code>wrapper</code> is returned.</li> </ul> </li> </ul> </li> <li> <p>After returning:</p> <ul> <li><code>say_name</code> now points to that returned wrapper.</li> </ul> </li> <li> <p>So yes \u2014 effectively: <code>say_name = wrapper</code></p> <ul> <li>(But this wrapper is a unique instance of the inner function that remembers its own func.)</li> </ul> </li> <li> <p>When you call <code>say_name()</code>:</p> <ul> <li>You\u2019re calling that specific wrapper instance.</li> </ul> </li> <li> <p>It prints \"Hello!\", runs the remembered <code>func()</code> (the original <code>say_name</code>), then prints \"Goodbye!\".</p> </li> </ul>"},{"location":"Python/#perfect-example-stacked-decorators","title":"Perfect Example (Stacked Decorators)","text":"<p><pre><code>def outer_decorator(func):\n    def outer_wrapper():\n        print(\"&gt;&gt;&gt; Entering outer layer\")\n        func()\n        print(\"&lt;&lt;&lt; Exiting outer layer\")\n    return outer_wrapper\n\ndef inner_decorator(func):\n    def inner_wrapper():\n        print(\"&gt;&gt;&gt; Entering inner layer\")\n        func()\n        print(\"&lt;&lt;&lt; Exiting inner layer\")\n    return inner_wrapper\n\n@outer_decorator\n@inner_decorator\ndef main_task():\n    print(\"Performing main task...\")\n\nmain_task()\n</code></pre> - Python defines both decorators     - <code>outer_decorator</code> and <code>inner_decorator</code> are just stored \u2014 no execution yet.</p> <ul> <li> <p>Python reaches the decorator assignment</p> <ul> <li><code>@outer_decorator</code> (top)</li> <li><code>@inner_decorator</code> (bottom)</li> <li>The bottom decorator runs first.</li> </ul> </li> <li> <p>\u2699 Inner Decorator</p> </li> <li>Executes <code>inner_decorator(main_task)</code>.<ul> <li><code>func</code> \u2192 original <code>main_task</code>.</li> <li>Defines <code>inner_wrapper</code>.</li> <li>Returns <code>inner_wrapper</code>.</li> </ul> </li> <li> <p>NOW</p> <p><code>main_task = inner_wrapper</code> (a unique instance that remembers the original <code>main_task</code>).</p> </li> <li> <p>\u2699 Outer Decorator</p> </li> <li>Executes <code>outer_decorator(inner_wrapper)</code>.<ul> <li><code>func</code> \u2192 the <code>inner_wrapper</code> (returned from previous step).</li> <li>Defines <code>outer_wrapper</code>.</li> <li>Returns <code>outer_wrapper</code>.</li> </ul> </li> <li>Now:   <p><code>main_task = outer_wrapper</code>.  </p> </li> </ul> <p>\u25b6 When <code>main_task()</code> is called: - Python calls <code>outer_wrapper()</code>     - Prints <code>&gt;&gt;&gt; Entering outer layer</code>     - Calls <code>func()</code> \u2192 that\u2019s <code>inner_wrapper</code>         - Prints <code>&gt;&gt;&gt; Entering inner layer</code>          - Calls <code>func()</code> \u2192 original <code>main_task</code>              - Prints <code>Performing main task...</code>          - Prints <code>&lt;&lt;&lt; Exiting inner layer</code>      - Prints `&lt;&lt;&lt; Exiting outer layer</p>"},{"location":"Python/#oop","title":"OOP","text":"<ul> <li>Classes - Blueprints</li> <li>Objects - Instances of Blueprints</li> <li>Attributes - Variables(data/properties) that belong to a object, set during the creation/instantiation of the object and define its state/characteristics.<ul> <li><pre><code># define the name of the class\nclass ClassName:\n    # function that is executed at the time of the creation of the instance\n    def __init__(self, attribute_1, attribute_2): # self refers to the instance of the class being created\n        # whatever the arguments/attributes passed during the creation process, it will be assigned to that instance of the class\n        self.attribute_1 = attribute_1\n        self.attribute_2 = attribute_2\n\n    # custom functions(known as methods) to give some behavior \n    # self parameter is used so that it can interact with the instance of the class\n    def some_function(self):\n        # CODE HERE\n\n# creating the object\nobject_var = ClassName(\"attribute_1\", \"property_2\")\n\n# accessing the attributes of the created object\nprint(object_var.attribute_1)\n\n# accessing or using the method/function of the class\nobject_var.some_function()\n</code></pre></li> </ul> </li> </ul>"},{"location":"Python/#functions-vs-methods","title":"Functions vs Methods","text":"<p>Functions are independent and can be called on their own but Methods can only be called via an instance of that class in which the method is defined.</p>"},{"location":"Python/#inheritance-polymorphism-and-encapsulation","title":"Inheritance, Polymorphism and Encapsulation","text":"<p>The concept which allows to create new classes with the properties of some existing classes.  It is used when you want to have a class with its unique properties and some properties which are being inherited from other class as well.</p> <p>The one which is inheriting the properties is known as Subclass or Child class and the one whose properties are being inherited is known as Superclass or Parent Class</p> <p>In the below example, the <code>Dog</code> and <code>Cat</code>, both classes have the behavior/method <code>Moving()</code>, but only Dog class can <code>Bark()</code> and only Cat class can <code>meow()</code>.</p> <pre><code>class Animal:\n    def __init__(self):\n        pass\n\n    def can_move(self):\n        # instance of the class &gt;&gt;&gt; go to the class that created the instance &gt;&gt;&gt; get of the value of its name attribute\n        print(self.__class__.__name__ + \" can move\")\n\nclass Dog(Animal):\n    def bark(self):\n        print(\"I can bark, cannot meow\")\n\nclass Cat(Animal):\n    def meow(self):\n        print('I can Meow, cannot bark')\n\nmy_dog = Dog()\nmy_cat = Cat()\n\nmy_dog.can_move()\nmy_dog.bark()\nmy_cat.can_move()\nmy_cat.meow()\n</code></pre> <p>The child class inherits all the attributes and methods of the parent class. <pre><code>class Animal:\n    def __init__(self, name):\n        self.name = name\n\n    def can_move(self):\n        print(\"Can Move\")\n\nclass Dog(Animal):\n    def __init__(self, name, breed, height):\n        # by default, using a __init__() in subclass, overrides the init of superclass\n        # # # the new attributes will be set and parent class attribute will be skipped\n        # # # so even though the inheritence will be there, init will not be inherited\n        # if you want to use the attributes of the init class of parent class as well as new attributes for that class, super() is basically used to access the parent class or superclass\n        super().__init__(name)\n        self.breed = breed\n        self.height = height\n\n    def bark(self):\n        # to call a superclass's method in the child's class\n        super().can_move()\n        print(\"I can bark, cannot meow\")\n\n# if the method is same in both, child and parent class, the child class's method will override the parent class's method.\n</code></pre></p> <p>Polymorphism: When the subclass(s) and superclass have same method name, the subclass's method will override the superclass behavior. Hence different class can respond to same methods in their own way. <pre><code>class Animal:\n    def speak(self):\n        print(\"Some generic sound\")\n\nclass Dog(Animal):\n    def speak(self):\n        print(\"Woof!\")\n\nclass Cat(Animal):\n    def speak(self):\n        print(\"Meow!\")\n\nanimals = [Dog(), Cat(), Animal()]\n\nfor a in animals:\n    a.speak()\n</code></pre> Output will be <pre><code>Woof!\nMeow!\nSome generic sound\n</code></pre></p> <p>Can be observed in the above example, the same method, <code>speak()</code> is being used with different classes and different classes are responding to it in their own way.</p> <p>Encapsulation: Hiding the internal data and controlling the access to it through methods only. (getters/setters)</p> <p><pre><code>class Car:\n    def __init__(self, model, year, odometer):\n        self.model = model\n        self.year = year\n        self.odometer = odometer\n\n    def describe_car(self):\n        print(self.year, self.model)\n\n    def read_meter(self):\n        print(f\"Reading is: {self.odometer}\")\n\nc = Car(\"BMW\", 2000, 15000)\n\nc.describe_car()\nc.read_meter()     # Reading is: 15000 \nc.odometer = 10000\nc.read_meter()     # Reading is: 10000\n</code></pre> As can be seen in the above code, the value of odometer can be changed by anyone outside the class, this is a security risk.</p> <p>Encapsulation or Data Hiding has TWO LEVELS  In the first one, we prefix an attribute with single underscore (_), which signals that It is meant for the internal use and should be viewed as protected. <pre><code>class Car:\n    def __init__(self, model, year, odometer):\n        self.model = model\n        self.year = year\n        # this is just a convention for the programmer to change the stuff whenever wants to \n        # this can still be access from the outside of the class via instance._attribute\n        # this is only for the convention to let the programmer know that this is something which is meant to be protected\n        # THIS BASICALLY MAKES THE ATTTRIBUTE PROTECTED\n        self._odometer = odometer\n\n    def describe_car(self):\n        print(self.year, self.model)\n\n    def read_meter(self):\n        print(f\"Reading is: {self._odometer}\")\n\nc = Car(\"BMW\", 2000, 15000)\n\nc.describe_car()      # 2000 BMW\nc.read_meter()        # Reading is: 15000                                  \nc.odometer = 20000\nc.read_meter()        # Reading is: 15000                                  \nc._odometer = 20000\nc.read_meter()        # Reading is: 20000        \n</code></pre></p> <p>TO REALLY DO SOME PROTECTION so that it cannot be accessed or changed from the outside of the class instance without the methods</p> <pre><code>class Car:\n    def __init__(self, model, year, odometer):\n        self.model = model\n        self.year = year\n        # THIS BASICALLY MAKES THE ATTTRIBUTE PRIVATE\n        self.__odometer = odometer\n\n    def describe_car(self):\n        print(self.year, self.model)\n\n    def read_meter(self):\n        print(f\"Reading is: {self.__odometer}\")\n\nc = Car(\"BMW\", 2000, 15000)\n\nc.describe_car()\nc.read_meter()          # Reading is: 15000\nc.odometer = 20000\nc.read_meter()          # Reading is: 15000\nc.__odometer = 20000\nc.read_meter()          # Reading is: 15000\n# as can be observed that the attribute still not changed and still using the one that was using during the creation of the instance\n\n# this is because\n# __ basically leads to name mangling\n# internall, __odometer is now actually _Car__odometer\n# which can be been seen in the output of the current program below\nprint(c.__dict__)\n\n# The lines that tried to update the odometer failed in updating the value and new attributes are added which are just there but they are not being displayed or used by any of the methods of the Class\n# however, the protected attribute here can still be accessed via _Car__odometer because internally it is name mangled\n</code></pre> <pre><code>2000 BMW\nReading is: 15000                                  \nReading is: 15000\nReading is: 15000\n{'model': 'BMW', 'year': 2000, '_Car__odometer': 15000, 'odometer': 20000, '__odometer': 20000}\n</code></pre> <p>The Encapsulation via _ and __ can also be used with methods of the class. Protected can be used only by the Superclass and Subclass and Private can be used only within Superclass.</p>"},{"location":"Python/#class-and-static-methods","title":"Class and Static Methods","text":""},{"location":"Python/#classmethod","title":"@classmethod","text":"<pre><code>class Car:\n    wheels = 4  # class attribute\n    # these are the attributes that are universal to all the instances of the class, so changing this will affect the values to be change in all the instances of the class as well\n\n    def __init__(self, model):\n        self.model = model  # instance attribute\n\n    @classmethod\n    def change_wheels(cls, new_wheels):\n    # the first attribute given here is the class itself\n    # this method can be called with the instance or without the instance.\n    # when it will be called with an instance, @classmethod just let it to access the class of the instance and put it in the cls\n        cls.wheels = new_wheels\n\n# Using classmethod\nc1 = Car(\"BMW\")\nprint(c1.wheels)       # 4\n\nCar.change_wheels(6)   # change class attribute\n\nprint(Car.wheels)      # 6\nprint(c1.wheels)       # 6 (all instances see updated value)\n</code></pre>"},{"location":"Python/#staticmethod","title":"@staticmethod","text":"<p><pre><code>class Car:\n    wheels = 4\n\n    @staticmethod\n    def calculate_mileage(distance, fuel):\n        return distance / fuel  # just a utility function\n\n# Calling via class\nprint(Car.calculate_mileage(300, 10))  # 30.0\n\n# Calling via instance\nc1 = Car()\nprint(c1.calculate_mileage(150, 5))    # 30.0\n</code></pre> - The main point regarding the static method is that, it cannot access or modify or read any class attribute or any instance's attribute.  - It is just a normal function placed inside a Car. - Can be called either via Class or instance. - Will not access/modify the attributes unless specifically given.</p>"},{"location":"Python/#real-life-usecase","title":"REAL LIFE USECASE","text":"<pre><code>class BankAccount:\n    interest_rate = 0.05  # class-level attribute, same for all accounts\n    accounts_created = 0  # track how many accounts created\n\n    def __init__(self, name, balance):\n        self.name = name          # instance attribute\n        self.balance = balance    # instance attribute\n        BankAccount.accounts_created += 1\n\n    # \u2705 Normal instance method\n    def deposit(self, amount):\n        self.balance += amount\n        print(f\"{self.name} deposited {amount}. New balance: {self.balance}\")\n\n    # \u2705 Class method\n    @classmethod\n    def update_interest_rate(cls, new_rate):\n        cls.interest_rate = new_rate\n        print(f\"Updated interest rate to {cls.interest_rate}\")\n\n    # \u2705 Static method\n    @staticmethod\n    def validate_account_number(account_number):\n        if len(str(account_number)) == 10 and str(account_number).isdigit():\n            print(\"Valid account number\")\n            return True\n        print(\"Invalid account number\")\n        return False\n</code></pre>"},{"location":"SQL/","title":"SQL","text":"<ul> <li>columns - also known as attributes/properties</li> <li>table - also known as schema</li> </ul>"},{"location":"SQL/#select","title":"Select","text":"<p><pre><code>SELECT col1, col2, col3, ..\nFROM table_name\n\n-- to select all\nSELECT * \nFROM table_name\n\n-- conditionals\nSELECT col1, col2\nFROM table_name\nWHERE condition\nAND condition\nOR condition\nBETWEEN x AND y\nNOT BETWEEN a AND b\ncol IN ('e', 'f', 'g', 'h')\ncol NOT IN ('j', 'k', 'l', 'm')\n\n-- specific conditionals \nSELECT * \nFROM table_name\nWHERE col = 'something' -- case-sensitive equality\ncol != 'something' -- case-sensitive equality\ncol LIKE 'something' -- pattern matching or case-insensitive equality\n-- ILIKE is used for case-insensitive where LIKE is case-sensitive\ncol NOT LIKE 'something' -- pattern matching inequality \n-- wildcards are % - means any num of character and _ means only one character\ncol LIKE '%some%' -- any word with some in between\n-- handsomeness\ncol LIKE 'some%' -- start with some and end with anything\n-- someplace\ncol LIKE 'an_' -- start with any single letter and then some\n-- and, ant\n</code></pre> full text search ? - Apache Lucene or\u00a0Sphinx - dedicated external for long full text search</p>"},{"location":"SQL/#filtering-and-sorting","title":"Filtering and Sorting","text":"<pre><code>SELECT DISTINCT col -- discard rows that have duplicate values blindly\n-- can use multiple cols as well like this -&gt; DISTINCT col, col2, col3\n-- DISTINCT will be used on all of them\n-- can also be used within aggregates COUNT(DISTINCT col)\nFROM table_name\n-- grouping/GROUP BY is used for removing duplication on criteria\n\nSELECT col, col2\nFROM table_name\nWHERE condition --no necessary\nORDER BY col ASC -- or DESC\nLIMIT num -- reduce the number of rows to return\nOFFSET num -- how many rows to skip - OPTIONAL\n-- LIMIT and OFFSET are majorly used/written at the end of the statement/query\n\n-- when comparing date and time with the timestamp or date data, this is a better way\nWHERE timestamp_data &gt; 'date' -- '2010-01-01'\n</code></pre>"},{"location":"SQL/#case-ifthen-logic-in-sql","title":"CASE - if/then logic in SQL","text":"<p><pre><code>SELECT col, col2, col3\nCASE WHEN col = 'value' THEN 'value_2'\n    WHEN col2 = 'value2' THEN 'val2' -- multiple conditions can be used as well\nELSE NULL/'Value'\nFROM table_name\n</code></pre> IRL example <pre><code>SELECT player_name,\n       year,\n       CASE WHEN year = 'SR' THEN 'yes'\n            ELSE NULL END AS is_a_senior\n  FROM benn.college_football_players\n\n-- CAN also use multiple statements\nSELECT player_name,\n       weight,\n       CASE WHEN weight &gt; 250 THEN 'over 250'\n            WHEN weight &gt; 200 AND weight &lt;= 250 THEN '201-250'\n            WHEN weight &gt; 175 AND weight &lt;= 200 THEN '176-200'\n            ELSE '175 or under' END AS weight_group\n  FROM benn.college_football_players\n\n-- CAN also be used with aggregate functions\nSELECT CASE WHEN year = 'FR' THEN 'FR'\n            WHEN year = 'SO' THEN 'SO'\n            WHEN year = 'JR' THEN 'JR'\n            WHEN year = 'SR' THEN 'SR'\n            ELSE 'No Year Data' END AS year_group,\n            COUNT(1) AS count\n  FROM benn.college_football_players\n GROUP BY year_group\n</code></pre></p>"},{"location":"SQL/#multi-table-queries-joins","title":"Multi Table Queries - JOINS","text":"<ul> <li>primary key is needed - uniquely identifies the entity throughout the database</li> <li>JOIN - combines data - from two table - based on primary/unique key</li> </ul>"},{"location":"SQL/#inner-join","title":"Inner Join","text":"<p>matches rows of first table with second table - based on same key - result is big table with combined cols of both tables <pre><code>SELECT col, col2, ...\nFROM table_name\nINNER JOIN another_table -- can also use only JOIN but this enchances the readability\nON table_name.id = another_table.matching_id\nWHERE condition(s)\n</code></pre></p>"},{"location":"SQL/#outer-join","title":"Outer Join","text":"<p>Asymmetric data - use LEFT, RIGHT or FULL JOIN, (OUTER can be omitted) Left Join: returns all rows of left table A whether is match is found in right table B or not - The table with more DISTINCT rows should be considered as A, hence used with FROM - The table whose row you want to preserve should be considered as A or left table <pre><code>SELECT col1, col2, col3, FROM table_1 LEFT JOIN table_2 \n--                       table on left side    table on right side\nON table_1.col = table_2.col\n--    left         right\n</code></pre> Right Join: same as above but reversed, include rows of right table regardless of match found in left table Full Join: rows for both tables are kept, regardless of matching row exist or not <pre><code>SELECT col, col2\nFROM table_name\nLEFT/RIGHT/FULL JOIN another_table\nON table_name.id = another_table.matching_id\nWHERE conditions(s)\n</code></pre></p>"},{"location":"SQL/#unions","title":"UNIONs","text":""},{"location":"SQL/#null-values","title":"NULL values","text":"<ul> <li>good to reduce them as much as possible</li> <li>special attention as functions behave differently with NULL</li> <li>instead of NULL, use data-type appropriate value <ul> <li>0 for numerical data</li> <li>\"\" for string</li> </ul> </li> <li>NULL however can be used to store incomplete data<ul> <li>average of numerical data <pre><code>SELECT col, col2\nFROM table_name\nWHERE col IS/IS NOT NULL\n</code></pre></li> </ul> </li> </ul>"},{"location":"SQL/#expressions","title":"Expressions","text":"<p>Simple <pre><code>SELECT col/2 AS half_col\n--  expression    description\nFROM very_long_table_name AS short_name\nINNER JOIN mini_table\nON short_name.id = mini_table.matching_id\nWHERE condition(s)\n\n-- every database has its own mathematical, string and data functions, present in their docs\n</code></pre></p> <p>Aggregates <pre><code>SELECT agg_func(col) AS new_name FROM table_name\n-- if new_name contains spaces, use \"new name\" - double quotes\n-- this is the only place in sql where double quotes are used\nGROUP BY col -- group the rows that have same value in the col specified\nHAVING group_condition -- conditions that are applied on grouped data\n-- HAVING is not needed if GROUP BY is not being used\n\n/*\nCOUNT(*)   -- count all rows\nCOUNT(col) -- count non-NULL values in cols\n-- can also use numbers as the position of the col in the select statement\nMIN(col) -- will return smallest number, earlier date and string closest to 'A'\nMAX()\nAVG()\nSUM()\n*/\n</code></pre></p>"},{"location":"SQL/#order-of-execution","title":"Order of Execution","text":"<pre><code>| FROM \u2192 JOIN -- to determine the total working set\n| WHERE -- all rows and cols are passed to apply the conditions \n| GROUP BY -- to group on the basis of common data\n| HAVING -- if group by exist\n| SELECT -- select the part that is needed to be displayed\n| DISTINCT -- among the chosen column, remove the duplicates\n| ORDER BY -- rows are now sorted\n| LIMIT \u2192 OFFSET -- how much to display and from where to display\n\u2193\n</code></pre>"},{"location":"SQL/#data-types","title":"Data Types","text":"<p>List of the all the data types in SQL. - Data should be stored as optimal data type from the beginning, but if it is not, you can change it via query. - It is common for dates or numbers to be stored as strong which will be problematic when using some functions. - You can use <code>CAST(col AS data_type)</code> or <code>col::data_type</code></p>"},{"location":"SQL/#data-cleaning","title":"Data Cleaning","text":"<pre><code>LEFT(col, num) -- get the num amount of characters from the left side of the data of col\nRIGHT(col, num) -- same as above but for the right\nSUBSTR(col, start, steps) -- create a sub string like above but from middle\nLENGTH(col) -- length of the strings in the col\nTRIM('chars' FROM 'string') -- remove the chars from the beginning and end of the string\nPOSITION('char/substring' IN 'string') -- index of the first occurrence\n-- OR\nSTRPOS('string', 'char/substring') -- both are case sensitive\nCONCAT(col, 'string', col) -- nothing much to explain here\nUPPER(col)\nLOWER(col)\nEXTRACT('val' FROM date_format) -- extracting from the parts of the date\nDATE_TRUNC('va' FROM date_format) -- round off the date upto a specific val\n/*\nTHE AVAILABLE vals are\nyear, month, day, hour, minute, second, decade, dow\n-- dow means day of the week \n*/\nCOALESCE(col, 'string') -- replace the null values with string\n</code></pre>"},{"location":"SQL/#cte-common-table-expression","title":"CTE (Common Table Expression)","text":"<p>CTE - temporary table returned within a query, helps in splitting queries into readable chunks <pre><code>WITH temp_table_name AS\n(\nSELECT col, col2 FROM table_name\nWHERE condition\n)\nSELECT col2 FROM temp_table_name\n</code></pre></p>"},{"location":"SQL/#current-datatime-methods","title":"Current Data/Time Methods","text":"<p><pre><code>SELECT CURRENT_DATE AS date,\n       CURRENT_TIME AS time,\n       CURRENT_TIMESTAMP AS timestamp,\n       LOCALTIME AS localtime,\n       LOCALTIMESTAMP AS localtimestamp,\n       NOW() AS now\n\n-- FOR THE TIMEZONE STUFF\nSELECT CURRENT_TIME AS time,\n       CURRENT_TIME AT TIME ZONE 'PST' AS time_pst\n</code></pre> List of time zones</p>"},{"location":"SQL/#inserting-rows","title":"Inserting Rows","text":"<ul> <li>Schema - description of each table and data type of each col of the table <pre><code>INSERT INTO table_name\nVALUES (val1, val2, val3) -- as the cols are not specified, you must include values of all cols\n\n\n-- IF THE DATA IS NOT COMPLETE\nINSERT INTO table_name (col_name, col2, col3, col4)\nVALUES (val1, val2, val3, val4) -- this will be inserted in sequence to the above cols sequence\n-- col that is not mentioned here will be filled with default value(if not set)\n-- instead of values, you can also use expression to be inserted such as (2.4, 1000/500)\n</code></pre></li> </ul>"},{"location":"SQL/#updating-rows","title":"Updating Rows","text":"<pre><code>UPDATE table_name\nSET col = value_or_expression, \n    col2 = val2,\n    col3 = val3, etc\nWHERE conditions\n\n-- be extra careful setting the values\n-- check the proper cols and conditional statement\n\n:TIP\n-- first check the conditional query using SELECT whether you are updating the correct rows or not and then proceed to updation\n</code></pre>"},{"location":"SQL/#deleting-rows","title":"Deleting Rows","text":"<pre><code>DELETE FROM table_name\nWHERE condition -- if this is omitted, all rows are removed however quick way to clear the table if wants to \n\n:TIP\n-- run SELECT first to check the conditional\n-- read DELETE statement twice \n</code></pre>"},{"location":"SQL/#creating-tables","title":"Creating Tables","text":"<pre><code>CREATE TABLE IF NOT EXISTS table_name(\ncol1_name datatype TableConstraint DEFAULT default_value,\ncol2_name datatype TableConstraint DEFAULT defauly_vaue\n)\n-- TableConstraint is applied on the value inserted into the col\n</code></pre>"},{"location":"SQL/#table-data-types","title":"Table Data Types","text":"Data Type Description Integer Whole integer values Boolean int value of just 0 and 1 Float, Double, Real Store more precise numerical data;Different types is used as per the precision required Char(Character),Varchar, Text text based data types; the difference lies into the efficiency of database when working with themCHAR(n) - fixed size, less will be filled with paddingVARCHAR(n) - variable but max is n number of charsTEXT - unlimited DATE, DATETIME no explanation needed BLOB Binary data, must store with right metadata for requery"},{"location":"SQL/#table-constraints","title":"Table Constraints","text":"CONSTRAINTS Description PRIMARY KEY unique and each row can be identified with AUTOINCREMENT automatically filled and incremented with each row integrat UNIQUE cannot have duplic NOT NULL cannot be NULL or CHECK(exp) check whether the value inserted is valid o FOREIGN  Consistency check means each value in the col ensures it corresponds to another value in another col in another table nother"},{"location":"SQL/#altering-tables","title":"Altering Tables","text":"<pre><code>ALTER TABLE table_name\nADD col datatype constraints DEFAULT val -- to add a column\nDROP col                                 -- the col to be deleted\nRENAME TO new_table_name                 -- new table name\n</code></pre> <p>All databases support slightly different methods so use docs for it.</p>"},{"location":"SQL/#dropping-tables","title":"Dropping Tables","text":"<pre><code>DROP TABLE IF EXISTS table_name\n\n-- if it has FOREIGN KEY, either update the depended tables or remove those tables as well\n</code></pre>"},{"location":"SQL/#end","title":"END","text":"<p>The basics are covered above, if want to explore more, follow these. 1. Window Functions**** 2. Performance Tuning 3. Pivoting Data 4. Analytics</p>"},{"location":"SQL/#bigquery","title":"BigQuery","text":"<p>Docs</p>"},{"location":"SQL/#introduction","title":"Introduction","text":"<pre><code>from google.cloud import bigquery as bq\n\nclient = bq.Client() # centrol role in retrieving info from bigquery datasets\ndataset_ref = client.dataset(\"hacker_news\", project=\"bigquery-public-data\") # arguments are dataset and the project where the data set is stored\ndataset = client.get_dataset(dataset_ref) # fetching the database \n# this is only used for getting the info about the dataset and not the actual data in the dataset\n\ntables = list(client.list_tables(dataset)) # getting all the tables\nfor table in tables:\n    print(table.table_id) # getting the name of the tables\n\ntable_ref = dataset_ref.table(\"Table_name\")\ntable = client.get_table(table_ref) # to get a table\ntable.schema # to get schema\n\nclient.list_rows(table, max_result = 5).to_dataframe() # get the top 5 rows\n# bigquery library internally use pandas \n\nclient.list_rows(table, \n    selected_fields=table.schema[:1], \n    max_results=5\n).to_dataframe() # only first column\n</code></pre> <p>Client</p> <p>Go to server to run the query and get the data</p> <p>Project</p> <p>Which holds the datasets</p> <p>Datasets</p> <p>Which holds the tables</p> <p>Tables</p> <p>Hold the actual data in rows and columns   </p>"},{"location":"SQL/#running-queries","title":"Running Queries","text":"<p><pre><code>from google.cloud import bigquery\nclient = bq.Client()\n\nquery = \"\"\"\n    SQL STATEMENT/QUERY GOES HERE\n\"\"\"\n\n# Date is the col name\n\"\"\"\nSELECT col, EXTRACT(DAY from Date) \nFROM table_name\n\"\"\"\n# to only get a part of the date\n\n\nclient.query(query)\n\n# to estimate the size of query without running it\ndry_run_config = bigquery.QueryJobConfig(dry_run=True)\ndry_run_query_job = client.query(query, job_config=dry_run_config)\nprint(\"This query will process {} bytes.\".format(dry_run_query_job.total_bytes_processed))\n\n# to limit the data we can scan \nONE_MB = 1000*1000\nsafe_config = bigquery.QueryJobConfig(maximum_bytes_billed=ONE_MB)\nsafe_query_job = client.query(query, job_config=safe_config) # will only run if its is less than 1 MB\nsafe_query_job.to_dataframe()\n</code></pre> Date Docs</p>"},{"location":"Seaborn/","title":"Seaborn","text":"<ul> <li><code>plt.figure(figsize=(x,y))</code> - set the width, height of the chart</li> <li><code>sns.lineplot(data=dataframe)</code></li> <li><code>plt.title(\"title\")</code><ul> <li><code>sns.lineplot(data=df[col1], lable='content1')</code></li> <li>`sns.lineplot(data=df[col2], lable='content2')<ul> <li>Both of the above will be plotted on the same graph even if there are 2 different statements</li> </ul> </li> </ul> </li> <li><code>plt.xlable(\"x axis label\")</code></li> <li><code>sns.barplot(x=df[col] or df.index, y=df[col])</code> </li> <li><code>sns.heatmap(data=df, annot=True)</code> Scatter Plots</li> <li><code>sns.scatterplot(x=df[col], y=df[col])</code> </li> <li><code>sns.regplot(x=df[col], y=df[col])</code> <ul> <li>Regression line, the line that best fits the data</li> </ul> </li> <li><code>sns.scatterplot(x=df[col], y=df[col], hue=df[col])</code> </li> <li><code>sns.lmplot(x=\"col1\", y=\"col2\", hue=\"col\", data=df)</code></li> <li> <p><code>sns.swarmplot(x=df[col], y=df[col])</code></p> </li> <li> <p><code>sns.histplot(df[col])</code></p> <ul> <li><code>sns.histplot(data=df, x=df[col], hue='col')</code></li> </ul> </li> <li><code>sns.kdeplot(df[col], shade=True)</code><ul> <li><code>sns.kdeplot(data=df, x=df[col], hue='col', shade=True)</code><ul> <li>2 KDE plots</li> </ul> </li> </ul> </li> <li><code>sns.jointplot(x=df[col1], y=df[col2], kind='kde')</code><ul> <li>2D KDE plot</li> </ul> </li> </ul> <p>Choosing the charts - Trends\u00a0- change in pattern     - <code>sns.lineplot</code>\u00a0-\u00a0best to show trend over time - Relationship\u00a0- relationships between variables     - <code>sns.barplot</code>\u00a0-\u00a0comparing quantities corresponding to different groups.     - <code>sns.heatmap</code>\u00a0-color-coded patterns in tables of numbers.     - <code>sns.scatterplot</code>\u00a0-\u00a0relationship between two continuous variables - if color-coded, also show relationship third\u00a0categorical variable     - <code>sns.regplot</code>\u00a0- regression line\u00a0in scatter plot - easier to see linear relationship     - <code>sns.lmplot</code>\u00a0- drawing multiple regression lines - contains multiple color coded lines     - <code>sns.swarmplot</code>\u00a0-\u00a0relationship between continuous variable and categorical variable. - Distribution\u00a0- show the possible values that we can expect to see in a variable, along with how likely they are.     - <code>sns.histplot</code>\u00a0-\u00a0 distribution of a single numerical variable.     - <code>sns.kdeplot</code>\u00a0-\u00a0estimated, smooth distribution of a single numerical variable (or two numerical variables).     - <code>sns.jointplot</code>\u00a0-  simultaneously displaying a 2D KDE plot with corresponding KDE plots for each individual variable.</p> <p>Styling - <code>sns.set_style('style')</code> - available styles are      - darkgrid     - whitegrid     - dark     - white     - ticks</p>"}]}